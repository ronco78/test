// Copyright 2016--2022 Lightbits Labs Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// you may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package docutils

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/olekukonko/tablewriter"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

var rootCmd *cobra.Command

// GenMarkdownTreeCustom is the the same as GenMarkdownTree, but
// with custom filePrepender and linkHandler.
func GenMarkdownTreeCustom(cmd *cobra.Command, dir string, filePrepender func(string) string, singleFile bool) error {
	if rootCmd == nil {
		rootCmd = cmd
	}
	f, err := createFile(cmd, dir, singleFile)
	if err != nil {
		return err
	}
	defer f.Close()

	if _, err := io.WriteString(f, filePrepender(f.Name())); err != nil {
		return err
	}
	if singleFile {
		// write command seperator
		cmdSeperator := "\n---\n\n"
		if rootCmd == cmd {
			cmdSeperator = ""
		}
		if _, err := io.WriteString(f, cmdSeperator); err != nil {
			return err
		}
	}
	linkHandler := func(x string) string { return x }
	if err = GenMarkdownCustom(cmd, f, linkHandler, singleFile); err != nil {
		return err
	}
	for _, c := range cmd.Commands() {
		if !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {
			continue
		}
		if err := GenMarkdownTreeCustom(c, filepath.Dir(f.Name()), filePrepender, singleFile); err != nil {
			return err
		}
	}
	return nil
}

// GenMarkdownCustom creates custom markdown output.
func GenMarkdownCustom(cmd *cobra.Command, w io.Writer, linkHandler func(string) string, singleFile bool) error {
	cmd.InitDefaultHelpCmd()
	cmd.InitDefaultHelpFlag()

	buf := new(bytes.Buffer)
	name := cmd.CommandPath()

	short := cmd.Short
	long := cmd.Long
	if len(long) == 0 {
		long = short
	}

	// in single file we want the first heading to be h1 and all the others to be h2
	if !singleFile || rootCmd == cmd {
		buf.WriteString("# " + name + "\n\n")
		buf.WriteString(short + "\n\n")
		buf.WriteString("## Synopsis\n\n")
		buf.WriteString(long + "\n\n")
	} else {
		buf.WriteString("## " + name + "\n\n")
		buf.WriteString(short + "\n\n")
		buf.WriteString("### Synopsis\n\n")
		buf.WriteString(long + "\n\n")
	}

	if cmd.Runnable() {
		buf.WriteString(fmt.Sprintf("```bash\n%s\n```\n\n", cmd.UseLine()))
	}

	if len(cmd.Example) > 0 {
		if !singleFile {
			buf.WriteString("## Examples\n\n")
			buf.WriteString(fmt.Sprintf("```bash\n%s\n```\n\n", cmd.Example))
		} else {
			buf.WriteString("### Examples\n\n")
			buf.WriteString(fmt.Sprintf("```bash\n%s\n```\n\n", cmd.Example))
		}
	}
	if err := printNonInheritedFlagsAsTable(buf, cmd, name); err != nil {
		return err
	}
	if !cmd.DisableAutoGenTag {
		buf.WriteString("##### Auto generated by spf13/cobra on " + time.Now().Format("2-Jan-2006") + "\n")
	}
	_, err := buf.WriteTo(w)
	return err
}

func createFile(cmd *cobra.Command, dir string, singleFile bool) (*os.File, error) {
	folder := dir
	var filename string
	var f *os.File
	var err error
	if !singleFile {
		basename := strings.Replace(cmd.CommandPath(), " ", "_", -1) + ".md"
		if cmd.HasSubCommands() {
			// create subfolder for parent commands, skip the root command.
			// we name the parent command as README.md but not the root command.
			if rootCmd != cmd {
				folder = filepath.Join(dir, cmd.Name())
				if err := os.MkdirAll(folder, os.ModePerm); err != nil {
					log.Errorf("%v", err)
					return nil, err
				}
				basename = "README.md"
			}
		}
		filename = filepath.Join(folder, basename)
		f, err = os.Create(filename)
	} else {
		filename = filepath.Join(folder, rootCmd.Name()+".md")
		f, err = os.OpenFile(filename, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666)
	}
	if err != nil {
		return nil, err
	}
	return f, nil
}

func printOptions(buf *bytes.Buffer, cmd *cobra.Command, name string) error {
	flags := cmd.NonInheritedFlags()
	flags.SetOutput(buf)
	if flags.HasFlags() {
		buf.WriteString("### Options\n\n```bash\n")
		flags.PrintDefaults()
		buf.WriteString("```\n\n")
	}
	return nil
}

func printPersistantOptions(buf *bytes.Buffer, cmd *cobra.Command, name string) error {
	flags := cmd.PersistentFlags()
	flags.SetOutput(buf)
	if flags.HasFlags() {
		buf.WriteString("### Persistant Options\n\n```bash\n")
		flags.PrintDefaults()
		buf.WriteString("```\n\n")
	}
	return nil
}

func printNonInheritedFlagsAsTable(buf *bytes.Buffer, cmd *cobra.Command, name string) error {
	flags := cmd.NonInheritedFlags()
	return printOptionsAsMarkdownTable(buf, cmd, name, flags)
}

func printPersistentFlagsAsTable(buf *bytes.Buffer, cmd *cobra.Command, name string) error {
	flags := cmd.PersistentFlags()
	return printOptionsAsMarkdownTable(buf, cmd, name, flags)
}

func printOptionsAsMarkdownTable(buf *bytes.Buffer, cmd *cobra.Command, name string, flags *pflag.FlagSet) error {
	if !flags.HasFlags() {
		return nil
	}
	data := [][]string{}

	flags.VisitAll(func(flag *pflag.Flag) {
		if flag.Deprecated != "" || flag.Hidden {
			return
		}

		entry := []string{}
		entry = append(entry, fmt.Sprintf("--%s", flag.Name))
		// short option
		if flag.Shorthand != "" && flag.ShorthandDeprecated == "" {
			entry = append(entry, fmt.Sprintf("-%s", flag.Shorthand))
		} else {
			entry = append(entry, "")
		}
		// add variable type
		entry = append(entry, flag.Value.Type())

		// add default values
		if !defaultIsZeroValue(flag) {
			if flag.Value.Type() == "string" {
				entry = append(entry, fmt.Sprintf("%q", flag.DefValue))
			} else {
				entry = append(entry, fmt.Sprintf("%s", flag.DefValue))
			}
		} else {
			entry = append(entry, "")
		}

		// add description
		_, usage := pflag.UnquoteUsage(flag)
		entry = append(entry, usage)
		// if varname != "" {
		// 	//line += " " + varname
		// }
		// if flag.NoOptDefVal != "" {
		// 	switch flag.Value.Type() {
		// 	case "string":
		// 		//line += fmt.Sprintf("[=\"%s\"]", flag.NoOptDefVal)
		// 	case "bool":
		// 		if flag.NoOptDefVal != "true" {
		// 			//line += fmt.Sprintf("[=%s]", flag.NoOptDefVal)
		// 		}
		// 	case "count":
		// 		if flag.NoOptDefVal != "+1" {
		// 			//line += fmt.Sprintf("[=%s]", flag.NoOptDefVal)
		// 		}
		// 	default:
		// 		//line += fmt.Sprintf("[=%s]", flag.NoOptDefVal)
		// 	}
		// }

		// add the entry to the data list.
		data = append(data, entry)

	})

	//table := tablewriter.NewWriter(os.Stdout)
	table := tablewriter.NewWriter(buf)
	table.SetHeader([]string{"Option", "Short", "Type", "Default", "Description"})
	table.SetBorders(tablewriter.Border{Left: true, Top: false, Right: true, Bottom: false})
	table.SetColWidth(100)
	table.SetCenterSeparator("|")
	table.AppendBulk(data) // Add Bulk Data
	table.Render()
	return nil
}

// defaultIsZeroValue returns true if the default value for this flag represents
// a zero value.
func defaultIsZeroValue(f *pflag.Flag) bool {
	switch f.Value.String() {
	case "[]":
		return true
	case "0s":
		return true
	case "false":
		return true
	case "<nil>":
		return true
	case "":
		return true
	case "0":
		return true
	}
	return false
}
